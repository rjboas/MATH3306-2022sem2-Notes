% !TeX TS-program = xelatex
% !TeX options = -aux-directory=Debug -shell-escape -file-line-error -interaction=nonstopmode -halt-on-error -synctex=1 "%DOC%"
\documentclass{article}
\input{LaTeX-Submodule/template.tex}

% Additional packages & macros
\geometry{a4paper}
\DeclareMathOperator{\blank}{\text{\textvisiblespace}}

\usepackage{tikz}
\usetikzlibrary{automata} % Import library for drawing automata
\usetikzlibrary{positioning} % ...positioning nodes
\usetikzlibrary{arrows.meta} % ...customizing arrows
\tikzset{
    node distance=2.0cm, % Minimum distance between two nodes. Change if necessary.
    every state/.style={ % Sets the properties for each state
        semithick,
        fill=gray!10
    },
    initial text={}, % No label on start arrow
    double distance=2pt, % Adjust appearance of accept states
    every edge/.style={ % Sets the properties for each transition
        draw,
        ->,
        % >=stealth’, % Makes edges directed with bold arrowheads
        auto,
        semithick
    }
}

% Header and footer
% ! Unit name
\newcommand{\unitName}{Set Theory \& Mathematical Logic}
% ! Unit code
\newcommand{\unitCode}{MATH3306}
% ! Unit semester 
\newcommand{\unitTime}{Semester 2, 2022}
% ! Unit coordinator name
\newcommand{\unitCoordinator}{Professor Benjamin Burton}
% ! Document authors
\newcommand{\documentAuthors}{Rohan Boas}

\fancyhead[L]{\unitName}
\fancyhead[R]{\leftmark}
\fancyfoot[C]{\thepage}

% Copyright
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={4.0},
    imagewidth={5em},
    hyphenation={raggedright}
]{doclicense}

\date{}

\begin{document}

\begin{titlepage}
    \vspace*{\fill}
    \begin{center}
        \Large{\unitCode} \\[0.05in]
        \LARGE{\textbf{\unitName}} \\[0.1in]
        \normalsize{\unitTime} \\[0.2in]
        \normalsize\textit{\unitCoordinator} \\[0.2in]
        \documentAuthors
    \end{center}
    \vspace*{\fill}
    \doclicenseThis
    \thispagestyle{empty}
\end{titlepage}
\newpage

\tableofcontents
\newpage

\section{Introductory notes}
\subsection{Gödel's incompleteness theorem}
\begin{theorem}[Gödel's incompleteness theorem, informal version]
    There are true mathematical statements that cannot be proven.
\end{theorem}
\begin{proof}[``Proof'']
    Take the statement ``This statement has no proof.''

    \emph{Assume it is false.}
    This implies that the statement has a proof.
    If the statement has a proof, it must be true, contradiction!

    \emph{Assume it is true.}
    This implies that the statement has no proof.
    Therefore, the statement cannot be proven.
\end{proof}
\subsection{The halting problem}
We would like to be able to know if an algorithm or program
will halt or will loop forever.
Can we write an algorithm which can tell us whether or not
a given program will halt on a given input?
This is known as the halting problem.
The halting problem is undecidable.
\begin{proof}[Proof by contradiction]
    Say there does exist some program H which solves the halting problem.
    Let us define H.
    H takes as inputs a program, \(x\),
    and an input for that program, \(y\).

    \[
        \text{H}(x,y) =
        \begin{cases}
            \text{YES}, \quad & \text{if } x \text{ halts on input } y         \\
            \text{NO},        & \text{if } x \text{ loops forever on input } y
        \end{cases}
    \]

    Let us define a program Foo.
    \[
        \text{Foo}(x) =
        \begin{cases}
            \text{loops forever}, \quad & \text{if } \text{H}(x,x) \text{ is YES} \\
            \text{halts}, \quad         & \text{if } \text{H}(x,x) \text{ is NO}  \\
        \end{cases}
    \]

    TODO: finish proof, maybe rewrite with diagram
\end{proof}

\subsection{Defining algorithms}
In defining algorithms, Turing machines
and recursive functions will be the primary focus.
Grammars and code are also alternatives.
\begin{definition}[Church-Turing thesis, informal version]
    Any reasonable definitions of ``algorithm'' are equivalent.
\end{definition}
\newpage
\section{Finite and deterministic state automata}
\subsection{Finite state automata}
\begin{definition}[Alphabet]
    An alphabet \(A\) is a finite set of symbols.
\end{definition}
\begin{definition}[Word]
    A word is a sequence of symbols from \(A\).
\end{definition}
\begin{theorem}
    Words can be concatenated.
    E.g. \ for words \(\alpha\) representing ``bob'',
    and \(\beta\) representing ``cat'',
    \(\alpha\beta\alpha\) represents ``bobcatbob''.
\end{theorem}
\begin{theorem}
    The set of words length \(m\) is \(A^m = A\times A\times \cdots \times A\).
\end{theorem}
\begin{theorem}
    The empty word (i.e.\ of length 0) is \(\varepsilon\).
\end{theorem}
\begin{theorem}
    \(A^*\) is the set of all words over \(A\). \(A^* = \bigcup_{m\ge 0} A^m\).
\end{theorem}
\begin{theorem}
    \(A^+\) is the set of all non-empty words over \(A\). \(A^+ = \bigcup_{m\ge 1} A^m\).
\end{theorem}
\begin{definition}[Language]
    A language is a subset of \(A^*\)
\end{definition}
\begin{definition}[Finite state automata]
    A finite state automaton (FSA)
    can be defined as the 5-tuple
    \(\left(Q, F, A, \tau, q_o\right)\) where
    \begin{itemize}
        \item    \(Q\) is a finite set of states,
        \item    \(F\subseteq Q\) is the set of final/accepting states,
        \item    \(A\) is a finite alphabet,
        \item    \(\tau\subseteq Q\times A\times Q\) is the set of transitions, and
        \item    \(q_0\) is the initial state.
    \end{itemize}
\end{definition}
\begin{definition}[Computation]
    A computation is a sequence \(q_0 a_1 q_1 a_2 \ldots a_n q_n\)
    such that each \(q_i a_{i+1} q_{i+1} \in \tau\).
\end{definition}
\begin{definition}[Successful]
    A computation is successful if \(q_n \in F\).
\end{definition}
\begin{definition}[Accepted]
    A word \(\alpha = a_1 a_2 \ldots a_n\)
    is accepted by the FSA if there is a
    successful computation \(q_0 a_1 q_1 a_2 \ldots a_n q_n\).
\end{definition}
\begin{definition}[Recognised]
    The language recognised by an FSA is
    the set of all words it accepts. 
\end{definition}
\begin{note}
    A FSA is like a backtracking search.
\end{note}
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
    \node[state] (A) {$-$};
    \node[state, above right of=A] (B) {};
    \node[state, below right of=B] (R) {$R$};
    \node[state, right of=B] (Z) {+};
    \draw (A) edge node {$a$} (B);
    \draw (A) edge node {$b$} (R);
    \draw (B) edge node {$a$} (R);
    \draw (B) edge node {$b$} (Z);
    \draw (R) edge[loop below] node {$a$} (R);
    \draw (R) edge[loop right] node {$b$} (R);
    \draw (Z) edge[loop above] node {$a$} (Z);
    \draw (Z) edge[loop right] node {$b$} (Z);
    \end{tikzpicture}
    \caption{
        A simple FSA (that is also a DFA)
    }
    \(-\) denotes the initial state, \(+\) is an accepting state,
    and \(R\) is a rejection state/``black hole''.
\end{figure}
\subsection{Deterministic finite state automata}
\begin{definition}[Deterministic finite state automata]
    A deterministic state automaton (DFA) is an FSA where
    \(
        \forall q \in Q, \forall a \in A,
        \exists! q' \in Q \st \left(q,a,q'\right)\in\tau
    \)
\end{definition}
\begin{theorem}
    The definition of DFA implies there exists a function \(\delta: Q \times A \to A\).
\end{theorem}
\begin{theorem}
    FSA and DFA solve the same problems.
    
    A DFA is already an FSA,
    and an FSA can be represented by a DFA of the reachable sets of states.
    Though, for an FSA with \(n\) states,
    the corresponding DFA has up to \(2^n\) states.
\end{theorem}
\begin{theorem}
    FSA/DFA can perform addition.
\end{theorem}
\begin{theorem}
    FSA/DFA \emph{cannot} perform multiplication.
\end{theorem}
\begin{theorem}
    To recognise an infinite language of a DFA with a finite complement,
    find the complement and swap accepting and rejecting states.
\end{theorem}

\newpage
\section{Turing machines}
\begin{definition}[Turing machine]
    A Turing machine (TM) is a FSA with infinite memory
    in the form of a tape.
    
    A Turing machine is a tuple \(\left(Q, F, \blank, A, I, \tau, q_0\right)\) where
    \begin{itemize}
        \item    \(Q\) is a finite set of states,
        \item    \(F\subseteq Q\) is the set of final/accepting states,
        \item    \(\blank\) is the ``blank'' symbol
        which is present on the tape where no new symbol has been written,
        \item    \(A\) is a finite alphabet of all symbols
        that may be on the tape (including \(\blank\)),
        \item    \(I\subseteq A - \left\{\blank\right\}\) is a finite alphabet of all
        symbols from the input sequence,
        \item    \(\tau\subseteq Q\times A\times Q\times A\times \left\{L, R\right\}\)
        is the set of transitions, and
        \item    \(q_0\) is the initial state.
    \end{itemize}
\end{definition}
\begin{definition}[Tape]
    A tape is a tuple \(\left(a, \alpha, \beta\right)\) where
    \begin{itemize}
        \item \(a\in A\),
        \item \(\alpha, \beta : \N\to A\), and
        \item \(\alpha(i), \beta(i) \ne \blank\) for only finitely many \(i\).
    \end{itemize}
\end{definition}
\begin{definition}[Configuration]
    A configuration is a snapshot of the state.

    A configuration is a tuple \(\left(q\in Q, a, \alpha, \beta\right)\).
\end{definition}
\begin{definition}[Reachable]
    A configuration \(c'\) is reachable from \(c\) in a single move if
    for \(c = \left(q, a, \alpha, \beta\right)\),
    (in the case of moving to the right)
    \(c' = \left(q', a(0), \alpha', \beta'\right)\) where
    \begin{itemize}
        \item \(\alpha'(i)=\alpha(i+1) \quad \forall i \in \N\),
        \item \(\beta'(i)=\begin{cases}
            \beta(i-1) & \forall i \ge 1 \\
            a' & i=0
        \end{cases}\), and
        \item \(\left(q, a, q', a', R\right)\in\tau\).
    \end{itemize}
\end{definition}
\begin{definition}[Computation]
    A computation is a finite sequence of configurations
    \(c_0 c_1 c_2 \ldots c_n\) \st
    \(c_i\) is reachable from \(c_{i-1}\) is a single move for all \(i\).
\end{definition}
\begin{definition}[Terminal]
    A configuration is terminal if no configuration is reachable from it.
    A Turing machine halts upon reaching such a configuration.
\end{definition}
\begin{definition}[Acceptinng]
    A Turing machine accepts a word \(w\in I^*\)
    if there exists some computation from the initial state \(c_w\)
    to some final state.
\end{definition}
\begin{definition}[Recognised]
    The language recognised by a Turing machine
    is the set of all words \(w \in I^*\) that the Turing machine accepts.
\end{definition}
\begin{definition}[Deterministic]
    A Turing machine is deterministic if   
    for all \(q\) and \(a\), there exists at most one tuple
    \(\left(q, a, q', a', d\right)\in\tau\).
\end{definition}
\begin{theorem}
    The transitions of a Turing machine are partial functions
    of the form
    \(\delta : Q\times A \to Q \times A \times \left\{L, R\right\}\)
\end{theorem}
% TODO: Aside on P vs NP?
\newpage
\section{Recursive functions}
\subsection{Base definitions}
\begin{definition}[Total function]
    A total function is an ordinary function, i.e.
    \(f: D\to C \st f\subseteq D\times C \text{ where }
    \forall d \in D \,\exists! c\in C \st \left( d, c \right)\in f\).
\end{definition}
\begin{definition}[Partial function]
    A partial function is \(f: D\to C \st f\subseteq D\times C \text{ where }
    \forall d \in D \,\exists_{\leq 1} c\in C \st \left( d, c \right)\in f\).
    I.e.\ undefined values are permitted.
\end{definition}
\begin{note}
    By convention, if not specified a function is \(f:\N^r\to\N\).
\end{note}

\subsection{Initial functions}
\begin{itemize}
    \item Zero: \(z:\N\to\N,\; z(n) = 0 \;\forall n\)
    \item Successor: \(\sigma:\N\to\N,\; \sigma(n) = n + 1 \;\forall n\)
    \item Projection: \(\pi_{i,n}:\N^n\to\N,\; \pi_{i,n}(k_1,\ldots,k_n) = k_i\)
\end{itemize}
\begin{definition}[Composition]
    Given \(g:\N^r\to\N\), and
    \(h_1,\ldots,h_r:\N^n\to\N\),
    \(f:\N^n\to\N\) is defined by
    \begin{align*}
        f(x_1,\ldots,x_n) 
        = g(& \\
        &\quad h_1(x_1,\ldots,x_n), \\
        &\qquad \vdots \\
        &\quad h_r(x_1,\ldots,x_n) \\
        )
    \end{align*}
\end{definition}
\subsection{Primitive recursion}
\begin{definition}[Primitive recursion]
    A primitive recursion on
    \(g:\N^n\to\N\) and
    \(h:\N^{n+2}\to\N\)
    is defined as \(f:\N^{n+1}\to\N\) \st
    \begin{align*}
        f\left(x_1,\ldots,x_n,0\right) = g(&x_1,\ldots,x_n) \\
        f\left(x_1,\ldots,x_n,y+1\right) = h(&
            \\
            &\quad x_1,\ldots,x_n, \\
            &\quad y, \\
            &\quad f\left(x_1,\ldots,x_n,y+1\right) \\
        &)
    \end{align*}
\end{definition}
\begin{note}
    Primitive recursion can only go from \(y\) to \(y+1\)
    and can only recurse over a signle variable.
\end{note}
\begin{note}
    We can only return a single integer, however,
    we can store pairs etc.\ by combining them in a retrievable way,
    for example, \(2^x \times 3^y\) could be chosen to store \(\left( x,y \right)\).
\end{note}
\begin{theorem}
    Primitive recursive functions are the smallest class of functions
    that contain the initial functions and
    is closed under composition and primitive recusrsion.
\end{theorem}
\begin{theorem}
    Addition can be represented as a primitive recusrion, \(s(x, y) = x+y\),
    with
    \begin{align*}
        s(x,0) &= \pi_{1,1}(x) \\
        s(x,y+1) &= \sigma(s(x,y))
    \end{align*}
\end{theorem}
\begin{theorem}
    Multiplication can be represented as a primitive recusrion, \(m(x, y) = x\times y\),
    with
    \begin{align*}
        m(x,0) &= z(x) \\
        m(x,y+1) &= s(x, m(x,y))
    \end{align*}
\end{theorem}
\begin{definition}[Primitive recusrive definition of a function]
    The primitive recusrive definition of a function
    \(f:\N^n\to\N\) is a finite set of functions \(\left\{f_0,\ldots,f_k\right\}\) \st
    \begin{align*}
        \forall i,\, f_i &= \begin{cases}
            \text{initial function} \\
            \text{composition of functions from } \left\{ f_j \,|\, j < i \right\} \\
            \text{primitive recursion of functions from } \left\{ f_j \,|\, j < i \right\}
        \end{cases} 
    \end{align*}
\end{definition}
\begin{theorem}
    A primitive recursion is equivalent to a primitive recusrive definition.
\end{theorem}
\begin{theorem}
    The constant function is \(c_i:\N\to\N\) where
    \(c_i(x)=i\).
    
    \[
        c_i=\overbrace{
            \sigma\left( \sigma\left(  \ldots \sigma\left( z \right) \right) \right)
        }^{i \text{ times}}
    \]
\end{theorem}
\begin{theorem}
    The sign function \(Sg:\N\to\N\) is
    \begin{equation*}
        Sg(x) = \begin{cases}
            0, & x = 0 \\
            1, & x > 0
        \end{cases}
    \end{equation*}

    TODO: show proof/primitive recursion
\end{theorem}
\begin{theorem}
    The predecessor function \(Pred:\N\to\N\) is
    \begin{equation*}
        Pred(x) = \begin{cases}
            0  , & x = 0 \\
            x-1, & x > 0
        \end{cases}
    \end{equation*}

    TODO: show proof/primitive recursion
\end{theorem}
\begin{theorem}
    The subtraction function \(\dotminus:\N^2\to\N\) is
    \begin{equation*}
        x\dotminus y = \begin{cases}
            0  , & x < y \\
            x-y, & x \ge y
        \end{cases}
    \end{equation*}

    TODO: show proof/primitive recursion
\end{theorem}
\begin{theorem}
    The absolute value function \(\left|x-y\right|:\N^2\to\N\) is
    \begin{equation*}
        \left|x-y\right| = \begin{cases}
            y-x  , & x < y \\
            x-y, & x \ge y
        \end{cases}
    \end{equation*}
    \[
        \left|x-y\right| = \left( x \dotminus y \right) + \left( y \dotminus x \right)
        = s\left( x \dotminus y, y \dotminus x \right)
    \]
\end{theorem}
\begin{theorem}
    The exponentiation function \(x^y:\N^2\to\N\) is
    \begin{align*}
            x^0 &= 1 \\
            x^{y+1} &= m(x^y, x)
    \end{align*}
\end{theorem}
\begin{theorem}
    For every function \(f:\N\to\N\) there is a summation function \(\sum_{i=0}^x f(i)\).
\end{theorem}
\begin{theorem}
    If \(f\) is primitive recursive then \(\sum_{i=0}^x f(i)\) is
    also primitive recusrive.
    
    TODO: add proof/illustration of prim. recursiveness
\end{theorem}
\begin{theorem}
    For every function \(f:\N\to\N\) there is a
    bounded minimisation function \(\min_{i\le y} f(i)\).
    This function gives the smallest \(f(i) \ne 0\),
    and gives \(y+1\) if all \(f(i) = 0\).

    TODO: add proof/illustration of prim. recursiveness
\end{theorem}
\begin{note}
    The following are not primitive recursive:
    \begin{enumerate}
        \item Unbounded summantion
        \item Unbounded minimum
    \end{enumerate}
\end{note}

\end{document}